/*
* generated by Xtext
*/

package net.certware.evidence.hugin.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class NetDSLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Assignment cDomainAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDomainDomainDefinitionParserRuleCall_0 = (RuleCall)cDomainAssignment.eContents().get(0);
		
		//Model:
		//	domain=DomainDefinition?;
		public ParserRule getRule() { return rule; }

		//domain=DomainDefinition?
		public Assignment getDomainAssignment() { return cDomainAssignment; }

		//DomainDefinition
		public RuleCall getDomainDomainDefinitionParserRuleCall_0() { return cDomainDomainDefinitionParserRuleCall_0; }
	}

	public class IntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Integer");
		private final Assignment cIAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIINTTerminalRuleCall_0 = (RuleCall)cIAssignment.eContents().get(0);
		
		//Integer:
		//	i=INT;
		public ParserRule getRule() { return rule; }

		//i=INT
		public Assignment getIAssignment() { return cIAssignment; }

		//INT
		public RuleCall getIINTTerminalRuleCall_0() { return cIINTTerminalRuleCall_0; }
	}

	public class DomainDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeaderAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeaderDomainHeaderParserRuleCall_0_0 = (RuleCall)cHeaderAssignment_0.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsDomainElementParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		
		//DomainDefinition:
		//	header=DomainHeader elements+=DomainElement*;
		public ParserRule getRule() { return rule; }

		//header=DomainHeader elements+=DomainElement*
		public Group getGroup() { return cGroup; }

		//header=DomainHeader
		public Assignment getHeaderAssignment_0() { return cHeaderAssignment_0; }

		//DomainHeader
		public RuleCall getHeaderDomainHeaderParserRuleCall_0_0() { return cHeaderDomainHeaderParserRuleCall_0_0; }

		//elements+=DomainElement*
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//DomainElement
		public RuleCall getElementsDomainElementParserRuleCall_1_0() { return cElementsDomainElementParserRuleCall_1_0; }
	}

	public class DomainHeaderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainHeader");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDomainHeaderAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAttributesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAttributesAttributeParserRuleCall_3_0 = (RuleCall)cAttributesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//DomainHeader:
		//	{DomainHeader} "net" "{" attributes+=Attribute* "}";
		public ParserRule getRule() { return rule; }

		//{DomainHeader} "net" "{" attributes+=Attribute* "}"
		public Group getGroup() { return cGroup; }

		//{DomainHeader}
		public Action getDomainHeaderAction_0() { return cDomainHeaderAction_0; }

		//"net"
		public Keyword getNetKeyword_1() { return cNetKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//attributes+=Attribute*
		public Assignment getAttributesAssignment_3() { return cAttributesAssignment_3; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_0() { return cAttributesAttributeParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class DomainElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicNodeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPotentialParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cClassDefinitionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//DomainElement:
		//	BasicNode | Potential | ClassDefinition;
		public ParserRule getRule() { return rule; }

		//BasicNode | Potential | ClassDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasicNode
		public RuleCall getBasicNodeParserRuleCall_0() { return cBasicNodeParserRuleCall_0; }

		//Potential
		public RuleCall getPotentialParserRuleCall_1() { return cPotentialParserRuleCall_1; }

		//ClassDefinition
		public RuleCall getClassDefinitionParserRuleCall_2() { return cClassDefinitionParserRuleCall_2; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStatesAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLabelAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPositionAttributeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSubtypeAttributeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStateValuesAttributeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cApplicationAttributeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNodeSizeAttributeParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Attribute:
		//	StatesAttribute | LabelAttribute | PositionAttribute | SubtypeAttribute | StateValuesAttribute | ApplicationAttribute
		//	| NodeSizeAttribute;
		public ParserRule getRule() { return rule; }

		//StatesAttribute | LabelAttribute | PositionAttribute | SubtypeAttribute | StateValuesAttribute | ApplicationAttribute |
		//NodeSizeAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//StatesAttribute
		public RuleCall getStatesAttributeParserRuleCall_0() { return cStatesAttributeParserRuleCall_0; }

		//LabelAttribute
		public RuleCall getLabelAttributeParserRuleCall_1() { return cLabelAttributeParserRuleCall_1; }

		//PositionAttribute
		public RuleCall getPositionAttributeParserRuleCall_2() { return cPositionAttributeParserRuleCall_2; }

		//SubtypeAttribute
		public RuleCall getSubtypeAttributeParserRuleCall_3() { return cSubtypeAttributeParserRuleCall_3; }

		//StateValuesAttribute
		public RuleCall getStateValuesAttributeParserRuleCall_4() { return cStateValuesAttributeParserRuleCall_4; }

		//ApplicationAttribute
		public RuleCall getApplicationAttributeParserRuleCall_5() { return cApplicationAttributeParserRuleCall_5; }

		//NodeSizeAttribute
		public RuleCall getNodeSizeAttributeParserRuleCall_6() { return cNodeSizeAttributeParserRuleCall_6; }
	}

	public class BasicNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeywordAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeywordBasicNodeKeywordParserRuleCall_0_0 = (RuleCall)cKeywordAssignment_0.eContents().get(0);
		private final Assignment cIdAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_1_0 = (RuleCall)cIdAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAttributesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAttributesAttributeParserRuleCall_3_0 = (RuleCall)cAttributesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BasicNode:
		//	keyword=BasicNodeKeyword id=ID? "{" attributes+=Attribute* "}";
		public ParserRule getRule() { return rule; }

		//keyword=BasicNodeKeyword id=ID? "{" attributes+=Attribute* "}"
		public Group getGroup() { return cGroup; }

		//keyword=BasicNodeKeyword
		public Assignment getKeywordAssignment_0() { return cKeywordAssignment_0; }

		//BasicNodeKeyword
		public RuleCall getKeywordBasicNodeKeywordParserRuleCall_0_0() { return cKeywordBasicNodeKeywordParserRuleCall_0_0; }

		//id=ID?
		public Assignment getIdAssignment_1() { return cIdAssignment_1; }

		//ID
		public RuleCall getIdIDTerminalRuleCall_1_0() { return cIdIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//attributes+=Attribute*
		public Assignment getAttributesAssignment_3() { return cAttributesAssignment_3; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_0() { return cAttributesAttributeParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class BasicNodeKeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicNodeKeyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cDiscreteKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cContinuousKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final Keyword cNodeKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cDecisionKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cUtilityKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cFunctionKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//BasicNodeKeyword:
		//	("discrete" | "continuous")? "node" | "decision" | "utility" | "function";
		public ParserRule getRule() { return rule; }

		//("discrete" | "continuous")? "node" | "decision" | "utility" | "function"
		public Alternatives getAlternatives() { return cAlternatives; }

		//("discrete" | "continuous")? "node"
		public Group getGroup_0() { return cGroup_0; }

		//("discrete" | "continuous")?
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"discrete"
		public Keyword getDiscreteKeyword_0_0_0() { return cDiscreteKeyword_0_0_0; }

		//"continuous"
		public Keyword getContinuousKeyword_0_0_1() { return cContinuousKeyword_0_0_1; }

		//"node"
		public Keyword getNodeKeyword_0_1() { return cNodeKeyword_0_1; }

		//"decision"
		public Keyword getDecisionKeyword_1() { return cDecisionKeyword_1; }

		//"utility"
		public Keyword getUtilityKeyword_2() { return cUtilityKeyword_2; }

		//"function"
		public Keyword getFunctionKeyword_3() { return cFunctionKeyword_3; }
	}

	public class StatesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatesAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStatesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatesSTRINGTerminalRuleCall_4_0 = (RuleCall)cStatesAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//StatesAttribute:
		//	{StatesAttribute} "states" "=" "(" states+=STRING* ")" ";";
		public ParserRule getRule() { return rule; }

		//{StatesAttribute} "states" "=" "(" states+=STRING* ")" ";"
		public Group getGroup() { return cGroup; }

		//{StatesAttribute}
		public Action getStatesAttributeAction_0() { return cStatesAttributeAction_0; }

		//"states"
		public Keyword getStatesKeyword_1() { return cStatesKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//states+=STRING*
		public Assignment getStatesAssignment_4() { return cStatesAssignment_4; }

		//STRING
		public RuleCall getStatesSTRINGTerminalRuleCall_4_0() { return cStatesSTRINGTerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class LabelAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LabelAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLabelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//LabelAttribute:
		//	"label" "=" value=STRING ";";
		public ParserRule getRule() { return rule; }

		//"label" "=" value=STRING ";"
		public Group getGroup() { return cGroup; }

		//"label"
		public Keyword getLabelKeyword_0() { return cLabelKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=STRING
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_0() { return cValueSTRINGTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class PositionAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PositionAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPositionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Action cIntegerLiteralAction_3 = (Action)cGroup.eContents().get(3);
		private final Assignment cXAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cXIntegerParserRuleCall_4_0 = (RuleCall)cXAssignment_4.eContents().get(0);
		private final Assignment cYAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cYIntegerParserRuleCall_5_0 = (RuleCall)cYAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//PositionAttribute:
		//	"position" "=" "(" {IntegerLiteral} x=Integer y=Integer ")" ";";
		public ParserRule getRule() { return rule; }

		//"position" "=" "(" {IntegerLiteral} x=Integer y=Integer ")" ";"
		public Group getGroup() { return cGroup; }

		//"position"
		public Keyword getPositionKeyword_0() { return cPositionKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//{IntegerLiteral}
		public Action getIntegerLiteralAction_3() { return cIntegerLiteralAction_3; }

		//x=Integer
		public Assignment getXAssignment_4() { return cXAssignment_4; }

		//Integer
		public RuleCall getXIntegerParserRuleCall_4_0() { return cXIntegerParserRuleCall_4_0; }

		//y=Integer
		public Assignment getYAssignment_5() { return cYAssignment_5; }

		//Integer
		public RuleCall getYIntegerParserRuleCall_5_0() { return cYIntegerParserRuleCall_5_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//";"
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class SubtypeAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubtypeAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSubtypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSubtypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cSubtypeAlternatives_2_0 = (Alternatives)cSubtypeAssignment_2.eContents().get(0);
		private final Keyword cSubtypeLabelKeyword_2_0_0 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(0);
		private final Keyword cSubtypeBooleanKeyword_2_0_1 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(1);
		private final Keyword cSubtypeNumberKeyword_2_0_2 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(2);
		private final Keyword cSubtypeIntervalKeyword_2_0_3 = (Keyword)cSubtypeAlternatives_2_0.eContents().get(3);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SubtypeAttribute:
		//	"subtype" "=" subtype=("label" | "boolean" | "number" | "interval") ";";
		public ParserRule getRule() { return rule; }

		//"subtype" "=" subtype=("label" | "boolean" | "number" | "interval") ";"
		public Group getGroup() { return cGroup; }

		//"subtype"
		public Keyword getSubtypeKeyword_0() { return cSubtypeKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//subtype=("label" | "boolean" | "number" | "interval")
		public Assignment getSubtypeAssignment_2() { return cSubtypeAssignment_2; }

		//"label" | "boolean" | "number" | "interval"
		public Alternatives getSubtypeAlternatives_2_0() { return cSubtypeAlternatives_2_0; }

		//"label"
		public Keyword getSubtypeLabelKeyword_2_0_0() { return cSubtypeLabelKeyword_2_0_0; }

		//"boolean"
		public Keyword getSubtypeBooleanKeyword_2_0_1() { return cSubtypeBooleanKeyword_2_0_1; }

		//"number"
		public Keyword getSubtypeNumberKeyword_2_0_2() { return cSubtypeNumberKeyword_2_0_2; }

		//"interval"
		public Keyword getSubtypeIntervalKeyword_2_0_3() { return cSubtypeIntervalKeyword_2_0_3; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class StateValuesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StateValuesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cState_valuesKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNumbersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumbersINTTerminalRuleCall_3_0 = (RuleCall)cNumbersAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//StateValuesAttribute:
		//	"state_values" "=" "(" numbers+=INT+ ")" ";";
		public ParserRule getRule() { return rule; }

		//"state_values" "=" "(" numbers+=INT+ ")" ";"
		public Group getGroup() { return cGroup; }

		//"state_values"
		public Keyword getState_valuesKeyword_0() { return cState_valuesKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//numbers+=INT+
		public Assignment getNumbersAssignment_3() { return cNumbersAssignment_3; }

		//INT
		public RuleCall getNumbersINTTerminalRuleCall_3_0() { return cNumbersINTTerminalRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ApplicationAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ApplicationAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyIDTerminalRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ApplicationAttribute:
		//	key=ID "=" value=STRING ";";
		public ParserRule getRule() { return rule; }

		//key=ID "=" value=STRING ";"
		public Group getGroup() { return cGroup; }

		//key=ID
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }

		//ID
		public RuleCall getKeyIDTerminalRuleCall_0_0() { return cKeyIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=STRING
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_0() { return cValueSTRINGTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class NodeSizeAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeSizeAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNode_sizeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cWidthAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWidthINTTerminalRuleCall_3_0 = (RuleCall)cWidthAssignment_3.eContents().get(0);
		private final Assignment cHeightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cHeightINTTerminalRuleCall_4_0 = (RuleCall)cHeightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// global magic for HUGIN GUI
		//NodeSizeAttribute:
		//	"node_size" "=" "(" width=INT height=INT ")" ";";
		public ParserRule getRule() { return rule; }

		//"node_size" "=" "(" width=INT height=INT ")" ";"
		public Group getGroup() { return cGroup; }

		//"node_size"
		public Keyword getNode_sizeKeyword_0() { return cNode_sizeKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//width=INT
		public Assignment getWidthAssignment_3() { return cWidthAssignment_3; }

		//INT
		public RuleCall getWidthINTTerminalRuleCall_3_0() { return cWidthINTTerminalRuleCall_3_0; }

		//height=INT
		public Assignment getHeightAssignment_4() { return cHeightAssignment_4; }

		//INT
		public RuleCall getHeightINTTerminalRuleCall_4_0() { return cHeightINTTerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class PotentialElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Potential");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPotentialKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cGraphAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGraphPotentialGraphParserRuleCall_1_0 = (RuleCall)cGraphAssignment_1.eContents().get(0);
		private final Assignment cModelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cModelPotentialModelParserRuleCall_2_0 = (RuleCall)cModelAssignment_2.eContents().get(0);
		
		//Potential:
		//	"potential" graph=PotentialGraph model=PotentialModel;
		public ParserRule getRule() { return rule; }

		//"potential" graph=PotentialGraph model=PotentialModel
		public Group getGroup() { return cGroup; }

		//"potential"
		public Keyword getPotentialKeyword_0() { return cPotentialKeyword_0; }

		//graph=PotentialGraph
		public Assignment getGraphAssignment_1() { return cGraphAssignment_1; }

		//PotentialGraph
		public RuleCall getGraphPotentialGraphParserRuleCall_1_0() { return cGraphPotentialGraphParserRuleCall_1_0; }

		//model=PotentialModel
		public Assignment getModelAssignment_2() { return cModelAssignment_2; }

		//PotentialModel
		public RuleCall getModelPotentialModelParserRuleCall_2_0() { return cModelPotentialModelParserRuleCall_2_0; }
	}

	public class PotentialGraphElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialGraph");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPotentialGraphAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cChildrenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChildrenIDTerminalRuleCall_2_0 = (RuleCall)cChildrenAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cVerticalLineKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParentsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParentsIDTerminalRuleCall_3_1_0 = (RuleCall)cParentsAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PotentialGraph:
		//	{PotentialGraph} "(" children+=ID* ("|" parents+=ID*)? ")";
		public ParserRule getRule() { return rule; }

		//{PotentialGraph} "(" children+=ID* ("|" parents+=ID*)? ")"
		public Group getGroup() { return cGroup; }

		//{PotentialGraph}
		public Action getPotentialGraphAction_0() { return cPotentialGraphAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//children+=ID*
		public Assignment getChildrenAssignment_2() { return cChildrenAssignment_2; }

		//ID
		public RuleCall getChildrenIDTerminalRuleCall_2_0() { return cChildrenIDTerminalRuleCall_2_0; }

		//("|" parents+=ID*)?
		public Group getGroup_3() { return cGroup_3; }

		//"|"
		public Keyword getVerticalLineKeyword_3_0() { return cVerticalLineKeyword_3_0; }

		//parents+=ID*
		public Assignment getParentsAssignment_3_1() { return cParentsAssignment_3_1; }

		//ID
		public RuleCall getParentsIDTerminalRuleCall_3_1_0() { return cParentsIDTerminalRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class PotentialModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPotentialModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributesPotentialAttributeParserRuleCall_2_0 = (RuleCall)cAttributesAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PotentialModel:
		//	{PotentialModel} "{" attributes+=PotentialAttribute* "}";
		public ParserRule getRule() { return rule; }

		//{PotentialModel} "{" attributes+=PotentialAttribute* "}"
		public Group getGroup() { return cGroup; }

		//{PotentialModel}
		public Action getPotentialModelAction_0() { return cPotentialModelAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//attributes+=PotentialAttribute*
		public Assignment getAttributesAssignment_2() { return cAttributesAssignment_2; }

		//PotentialAttribute
		public RuleCall getAttributesPotentialAttributeParserRuleCall_2_0() { return cAttributesPotentialAttributeParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PotentialAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialAttribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPotentialDataAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPotentialTableAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PotentialAttribute:
		//	PotentialDataAttribute | // TODO fragile
		//	PotentialTableAttribute;
		public ParserRule getRule() { return rule; }

		//PotentialDataAttribute | // TODO fragile
		//PotentialTableAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//PotentialDataAttribute
		public RuleCall getPotentialDataAttributeParserRuleCall_0() { return cPotentialDataAttributeParserRuleCall_0; }

		//// TODO fragile
		//PotentialTableAttribute
		public RuleCall getPotentialTableAttributeParserRuleCall_1() { return cPotentialTableAttributeParserRuleCall_1; }
	}

	public class PotentialDataAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialDataAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPotentialDataAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDataKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDataAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDataMatrixRowParserRuleCall_3_0 = (RuleCall)cDataAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PotentialDataAttribute:
		//	{PotentialDataAttribute} "data" "=" data=MatrixRow ";";
		public ParserRule getRule() { return rule; }

		//{PotentialDataAttribute} "data" "=" data=MatrixRow ";"
		public Group getGroup() { return cGroup; }

		//{PotentialDataAttribute}
		public Action getPotentialDataAttributeAction_0() { return cPotentialDataAttributeAction_0; }

		//"data"
		public Keyword getDataKeyword_1() { return cDataKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//data=MatrixRow
		public Assignment getDataAssignment_3() { return cDataAssignment_3; }

		//MatrixRow
		public RuleCall getDataMatrixRowParserRuleCall_3_0() { return cDataMatrixRowParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class MatrixRowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MatrixRow");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cMatrixRowAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cR5Assignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cR5List5ParserRuleCall_0_1_0 = (RuleCall)cR5Assignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMatrixRowAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cR4Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cR4List4ParserRuleCall_1_1_0 = (RuleCall)cR4Assignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cMatrixRowAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cR3Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cR3List3ParserRuleCall_2_1_0 = (RuleCall)cR3Assignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cMatrixRowAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cR2Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cR2List2ParserRuleCall_3_1_0 = (RuleCall)cR2Assignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cMatrixRowAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cR1Assignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cR1List1ParserRuleCall_4_1_0 = (RuleCall)cR1Assignment_4_1.eContents().get(0);
		
		//// tough to do arbitrary nesting in xtext, so do reasonably deep rules
		//// validation rules should check content patterns
		//MatrixRow:
		//	{MatrixRow} // trying for big enough to handle barley
		//	r5+=List5+ | {MatrixRow} // '(' '(' '(' r31+=List1+ ')' '(' r32+=List1+ ')' '(' r33+=List1+ ')' ')' ')'
		//	r4+=List4+ | {MatrixRow} //'(' '(' r21+=List+ ')' '(' r22+=List+ ')' ')'
		//	r3+=List3+ | {MatrixRow} // '(' r11+=List+ ')'
		//	r2+=List2+ | {MatrixRow} r1=List1;
		public ParserRule getRule() { return rule; }

		//{MatrixRow} // trying for big enough to handle barley
		//r5+=List5+ | {MatrixRow} // '(' '(' '(' r31+=List1+ ')' '(' r32+=List1+ ')' '(' r33+=List1+ ')' ')' ')'
		//r4+=List4+ | {MatrixRow} //'(' '(' r21+=List+ ')' '(' r22+=List+ ')' ')'
		//r3+=List3+ | {MatrixRow} // '(' r11+=List+ ')'
		//r2+=List2+ | {MatrixRow} r1=List1
		public Alternatives getAlternatives() { return cAlternatives; }

		//{MatrixRow} // trying for big enough to handle barley
		//r5+=List5+
		public Group getGroup_0() { return cGroup_0; }

		//{MatrixRow}
		public Action getMatrixRowAction_0_0() { return cMatrixRowAction_0_0; }

		//// trying for big enough to handle barley
		//r5+=List5+
		public Assignment getR5Assignment_0_1() { return cR5Assignment_0_1; }

		//List5
		public RuleCall getR5List5ParserRuleCall_0_1_0() { return cR5List5ParserRuleCall_0_1_0; }

		//{MatrixRow} // '(' '(' '(' r31+=List1+ ')' '(' r32+=List1+ ')' '(' r33+=List1+ ')' ')' ')'
		//r4+=List4+
		public Group getGroup_1() { return cGroup_1; }

		//{MatrixRow}
		public Action getMatrixRowAction_1_0() { return cMatrixRowAction_1_0; }

		//// '(' '(' '(' r31+=List1+ ')' '(' r32+=List1+ ')' '(' r33+=List1+ ')' ')' ')'
		//r4+=List4+
		public Assignment getR4Assignment_1_1() { return cR4Assignment_1_1; }

		//List4
		public RuleCall getR4List4ParserRuleCall_1_1_0() { return cR4List4ParserRuleCall_1_1_0; }

		//{MatrixRow} //'(' '(' r21+=List+ ')' '(' r22+=List+ ')' ')'
		//r3+=List3+
		public Group getGroup_2() { return cGroup_2; }

		//{MatrixRow}
		public Action getMatrixRowAction_2_0() { return cMatrixRowAction_2_0; }

		////'(' '(' r21+=List+ ')' '(' r22+=List+ ')' ')'
		//r3+=List3+
		public Assignment getR3Assignment_2_1() { return cR3Assignment_2_1; }

		//List3
		public RuleCall getR3List3ParserRuleCall_2_1_0() { return cR3List3ParserRuleCall_2_1_0; }

		//{MatrixRow} // '(' r11+=List+ ')'
		//r2+=List2+
		public Group getGroup_3() { return cGroup_3; }

		//{MatrixRow}
		public Action getMatrixRowAction_3_0() { return cMatrixRowAction_3_0; }

		//// '(' r11+=List+ ')'
		//r2+=List2+
		public Assignment getR2Assignment_3_1() { return cR2Assignment_3_1; }

		//List2
		public RuleCall getR2List2ParserRuleCall_3_1_0() { return cR2List2ParserRuleCall_3_1_0; }

		//{MatrixRow} r1=List1
		public Group getGroup_4() { return cGroup_4; }

		//{MatrixRow}
		public Action getMatrixRowAction_4_0() { return cMatrixRowAction_4_0; }

		//r1=List1
		public Assignment getR1Assignment_4_1() { return cR1Assignment_4_1; }

		//List1
		public RuleCall getR1List1ParserRuleCall_4_1_0() { return cR1List1ParserRuleCall_4_1_0; }
	}

	public class List5Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "List5");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cList5Action_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListList4ParserRuleCall_2_0 = (RuleCall)cListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//List5 returns MatrixRow:
		//	{List5} "(" list+=List4+ ")";
		public ParserRule getRule() { return rule; }

		//{List5} "(" list+=List4+ ")"
		public Group getGroup() { return cGroup; }

		//{List5}
		public Action getList5Action_0() { return cList5Action_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//list+=List4+
		public Assignment getListAssignment_2() { return cListAssignment_2; }

		//List4
		public RuleCall getListList4ParserRuleCall_2_0() { return cListList4ParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class List4Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "List4");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cList4Action_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListList3ParserRuleCall_2_0 = (RuleCall)cListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//List4 returns MatrixRow:
		//	{List4} "(" list+=List3+ ")";
		public ParserRule getRule() { return rule; }

		//{List4} "(" list+=List3+ ")"
		public Group getGroup() { return cGroup; }

		//{List4}
		public Action getList4Action_0() { return cList4Action_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//list+=List3+
		public Assignment getListAssignment_2() { return cListAssignment_2; }

		//List3
		public RuleCall getListList3ParserRuleCall_2_0() { return cListList3ParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class List3Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "List3");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cList3Action_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListList2ParserRuleCall_2_0 = (RuleCall)cListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//List3 returns MatrixRow:
		//	{List3} "(" list+=List2+ ")";
		public ParserRule getRule() { return rule; }

		//{List3} "(" list+=List2+ ")"
		public Group getGroup() { return cGroup; }

		//{List3}
		public Action getList3Action_0() { return cList3Action_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//list+=List2+
		public Assignment getListAssignment_2() { return cListAssignment_2; }

		//List2
		public RuleCall getListList2ParserRuleCall_2_0() { return cListList2ParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class List2Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "List2");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cList2Action_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListList1ParserRuleCall_2_0 = (RuleCall)cListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//List2 returns MatrixRow:
		//	{List2} "(" list+=List1+ ")";
		public ParserRule getRule() { return rule; }

		//{List2} "(" list+=List1+ ")"
		public Group getGroup() { return cGroup; }

		//{List2}
		public Action getList2Action_0() { return cList2Action_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//list+=List1+
		public Assignment getListAssignment_2() { return cListAssignment_2; }

		//List1
		public RuleCall getListList1ParserRuleCall_2_0() { return cListList1ParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class List1Elements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "List1");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cList1Action_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cItemsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cItemsUnaryExpressionParserRuleCall_2_0 = (RuleCall)cItemsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// TODO add normal distribution as an expression operation
		//List1 returns MatrixRow:
		//	{List1} "(" items+=unaryExpression* ")";
		public ParserRule getRule() { return rule; }

		//{List1} "(" items+=unaryExpression* ")"
		public Group getGroup() { return cGroup; }

		//{List1}
		public Action getList1Action_0() { return cList1Action_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//items+=unaryExpression*
		public Assignment getItemsAssignment_2() { return cItemsAssignment_2; }

		//unaryExpression
		public RuleCall getItemsUnaryExpressionParserRuleCall_2_0() { return cItemsUnaryExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class MeanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MeanExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMeanTermParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cMeanTermParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//// TODO redefine as an operator so it matches unary expressions
		////NormalDistribution 
		////	: 'normal' '(' mean=MeanExpression ',' variance=DOUBLE ')'
		////	;
		//MeanExpression:
		//	MeanTerm ("+" MeanTerm)*;
		public ParserRule getRule() { return rule; }

		//MeanTerm ("+" MeanTerm)*
		public Group getGroup() { return cGroup; }

		//MeanTerm
		public RuleCall getMeanTermParserRuleCall_0() { return cMeanTermParserRuleCall_0; }

		//("+" MeanTerm)*
		public Group getGroup_1() { return cGroup_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }

		//MeanTerm
		public RuleCall getMeanTermParserRuleCall_1_1() { return cMeanTermParserRuleCall_1_1; }
	}

	public class MeanTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MeanTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDOUBLETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cDOUBLETerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cIDTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//MeanTerm:
		//	DOUBLE | DOUBLE "*" ID | ID;
		public ParserRule getRule() { return rule; }

		//DOUBLE | DOUBLE "*" ID | ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//DOUBLE
		public RuleCall getDOUBLETerminalRuleCall_0() { return cDOUBLETerminalRuleCall_0; }

		//DOUBLE "*" ID
		public Group getGroup_1() { return cGroup_1; }

		//DOUBLE
		public RuleCall getDOUBLETerminalRuleCall_1_0() { return cDOUBLETerminalRuleCall_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_2() { return cIDTerminalRuleCall_1_2; }

		//ID
		public RuleCall getIDTerminalRuleCall_2() { return cIDTerminalRuleCall_2; }
	}

	public class PotentialTableAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PotentialTableAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNodesModelNodesAttributeParserRuleCall_0_0 = (RuleCall)cNodesAssignment_0.eContents().get(0);
		private final Assignment cSamplesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSamplesSamplesAttributeParserRuleCall_1_0 = (RuleCall)cSamplesAssignment_1.eContents().get(0);
		private final Assignment cDataAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDataModelDataAttributeParserRuleCall_2_0 = (RuleCall)cDataAssignment_2.eContents().get(0);
		
		//PotentialTableAttribute:
		//	nodes=ModelNodesAttribute samples=SamplesAttribute? data=ModelDataAttribute;
		public ParserRule getRule() { return rule; }

		//nodes=ModelNodesAttribute samples=SamplesAttribute? data=ModelDataAttribute
		public Group getGroup() { return cGroup; }

		//nodes=ModelNodesAttribute
		public Assignment getNodesAssignment_0() { return cNodesAssignment_0; }

		//ModelNodesAttribute
		public RuleCall getNodesModelNodesAttributeParserRuleCall_0_0() { return cNodesModelNodesAttributeParserRuleCall_0_0; }

		//samples=SamplesAttribute?
		public Assignment getSamplesAssignment_1() { return cSamplesAssignment_1; }

		//SamplesAttribute
		public RuleCall getSamplesSamplesAttributeParserRuleCall_1_0() { return cSamplesSamplesAttributeParserRuleCall_1_0; }

		//data=ModelDataAttribute
		public Assignment getDataAssignment_2() { return cDataAssignment_2; }

		//ModelDataAttribute
		public RuleCall getDataModelDataAttributeParserRuleCall_2_0() { return cDataModelDataAttributeParserRuleCall_2_0; }
	}

	public class ModelNodesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModelNodesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModelNodesAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModel_nodesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConfigurationsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConfigurationsIDTerminalRuleCall_4_0 = (RuleCall)cConfigurationsAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ModelNodesAttribute:
		//	{ModelNodesAttribute} "model_nodes" "=" "(" configurations+=ID* ")" ";";
		public ParserRule getRule() { return rule; }

		//{ModelNodesAttribute} "model_nodes" "=" "(" configurations+=ID* ")" ";"
		public Group getGroup() { return cGroup; }

		//{ModelNodesAttribute}
		public Action getModelNodesAttributeAction_0() { return cModelNodesAttributeAction_0; }

		//"model_nodes"
		public Keyword getModel_nodesKeyword_1() { return cModel_nodesKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//configurations+=ID*
		public Assignment getConfigurationsAssignment_4() { return cConfigurationsAssignment_4; }

		//ID
		public RuleCall getConfigurationsIDTerminalRuleCall_4_0() { return cConfigurationsIDTerminalRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class SamplesAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SamplesAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSamples_per_intervalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueINTTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SamplesAttribute:
		//	"samples_per_interval" "=" value=INT ";";
		public ParserRule getRule() { return rule; }

		//"samples_per_interval" "=" value=INT ";"
		public Group getGroup() { return cGroup; }

		//"samples_per_interval"
		public Keyword getSamples_per_intervalKeyword_0() { return cSamples_per_intervalKeyword_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=INT
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_2_0() { return cValueINTTerminalRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ModelDataAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModelDataAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModelDataAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModel_dataKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cSequenceAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSequenceExpressionSequenceParserRuleCall_4_0 = (RuleCall)cSequenceAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ModelDataAttribute:
		//	{ModelDataAttribute} "model_data" "=" "(" sequence=ExpressionSequence ")" ";";
		public ParserRule getRule() { return rule; }

		//{ModelDataAttribute} "model_data" "=" "(" sequence=ExpressionSequence ")" ";"
		public Group getGroup() { return cGroup; }

		//{ModelDataAttribute}
		public Action getModelDataAttributeAction_0() { return cModelDataAttributeAction_0; }

		//"model_data"
		public Keyword getModel_dataKeyword_1() { return cModel_dataKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//sequence=ExpressionSequence
		public Assignment getSequenceAssignment_4() { return cSequenceAssignment_4; }

		//ExpressionSequence
		public RuleCall getSequenceExpressionSequenceParserRuleCall_4_0() { return cSequenceExpressionSequenceParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class ClassDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElementsClassElementParserRuleCall_3_0 = (RuleCall)cElementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/////////////////////////////////////////////////////
		//// classes
		/////////////////////////////////////////////////////
		//ClassDefinition:
		//	"class" name=ID "{" elements+=ClassElement* "}";
		public ParserRule getRule() { return rule; }

		//"class" name=ID "{" elements+=ClassElement* "}"
		public Group getGroup() { return cGroup; }

		//"class"
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//elements+=ClassElement*
		public Assignment getElementsAssignment_3() { return cElementsAssignment_3; }

		//ClassElement
		public RuleCall getElementsClassElementParserRuleCall_3_0() { return cElementsClassElementParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ClassElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDomainElementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cClassInstanceParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ClassElement:
		//	DomainElement | Attribute | ClassInstance;
		public ParserRule getRule() { return rule; }

		//DomainElement | Attribute | ClassInstance
		public Alternatives getAlternatives() { return cAlternatives; }

		//DomainElement
		public RuleCall getDomainElementParserRuleCall_0() { return cDomainElementParserRuleCall_0; }

		//Attribute
		public RuleCall getAttributeParserRuleCall_1() { return cAttributeParserRuleCall_1; }

		//ClassInstance
		public RuleCall getClassInstanceParserRuleCall_2() { return cClassInstanceParserRuleCall_2; }
	}

	public class ClassInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInstanceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInstanceNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInstanceNameIDTerminalRuleCall_1_0 = (RuleCall)cInstanceNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cClassNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cClassNameIDTerminalRuleCall_3_0 = (RuleCall)cClassNameAssignment_3.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cInputAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cInputInputBindingsParserRuleCall_5_0 = (RuleCall)cInputAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cSemicolonKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cOutputAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cOutputOutputBindingsParserRuleCall_6_1_0 = (RuleCall)cOutputAssignment_6_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cLeftCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cAttributesAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cAttributesNodeAttributesParserRuleCall_9_0 = (RuleCall)cAttributesAssignment_9.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//ClassInstance:
		//	"instance" instanceName=ID ":" className=ID "(" input=InputBindings? (";" output=OutputBindings)? ")" "{"
		//	attributes=NodeAttributes "}";
		public ParserRule getRule() { return rule; }

		//"instance" instanceName=ID ":" className=ID "(" input=InputBindings? (";" output=OutputBindings)? ")" "{"
		//attributes=NodeAttributes "}"
		public Group getGroup() { return cGroup; }

		//"instance"
		public Keyword getInstanceKeyword_0() { return cInstanceKeyword_0; }

		//instanceName=ID
		public Assignment getInstanceNameAssignment_1() { return cInstanceNameAssignment_1; }

		//ID
		public RuleCall getInstanceNameIDTerminalRuleCall_1_0() { return cInstanceNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//className=ID
		public Assignment getClassNameAssignment_3() { return cClassNameAssignment_3; }

		//ID
		public RuleCall getClassNameIDTerminalRuleCall_3_0() { return cClassNameIDTerminalRuleCall_3_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//input=InputBindings?
		public Assignment getInputAssignment_5() { return cInputAssignment_5; }

		//InputBindings
		public RuleCall getInputInputBindingsParserRuleCall_5_0() { return cInputInputBindingsParserRuleCall_5_0; }

		//(";" output=OutputBindings)?
		public Group getGroup_6() { return cGroup_6; }

		//";"
		public Keyword getSemicolonKeyword_6_0() { return cSemicolonKeyword_6_0; }

		//output=OutputBindings
		public Assignment getOutputAssignment_6_1() { return cOutputAssignment_6_1; }

		//OutputBindings
		public RuleCall getOutputOutputBindingsParserRuleCall_6_1_0() { return cOutputOutputBindingsParserRuleCall_6_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_8() { return cLeftCurlyBracketKeyword_8; }

		//attributes=NodeAttributes
		public Assignment getAttributesAssignment_9() { return cAttributesAssignment_9; }

		//NodeAttributes
		public RuleCall getAttributesNodeAttributesParserRuleCall_9_0() { return cAttributesNodeAttributesParserRuleCall_9_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_10() { return cRightCurlyBracketKeyword_10; }
	}

	public class InputBindingsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InputBindings");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsInputBindingParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsInputBindingsParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//InputBindings:
		//	lhs=InputBinding "," rhs=InputBindings;
		public ParserRule getRule() { return rule; }

		//lhs=InputBinding "," rhs=InputBindings
		public Group getGroup() { return cGroup; }

		//lhs=InputBinding
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//InputBinding
		public RuleCall getLhsInputBindingParserRuleCall_0_0() { return cLhsInputBindingParserRuleCall_0_0; }

		//","
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }

		//rhs=InputBindings
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//InputBindings
		public RuleCall getRhsInputBindingsParserRuleCall_2_0() { return cRhsInputBindingsParserRuleCall_2_0; }
	}

	public class InputBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InputBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFormalAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFormalIDTerminalRuleCall_0_0 = (RuleCall)cFormalAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActualAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActualIDTerminalRuleCall_2_0 = (RuleCall)cActualAssignment_2.eContents().get(0);
		
		//InputBinding:
		//	formal=ID "=" actual=ID;
		public ParserRule getRule() { return rule; }

		//formal=ID "=" actual=ID
		public Group getGroup() { return cGroup; }

		//formal=ID
		public Assignment getFormalAssignment_0() { return cFormalAssignment_0; }

		//ID
		public RuleCall getFormalIDTerminalRuleCall_0_0() { return cFormalIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//actual=ID
		public Assignment getActualAssignment_2() { return cActualAssignment_2; }

		//ID
		public RuleCall getActualIDTerminalRuleCall_2_0() { return cActualIDTerminalRuleCall_2_0; }
	}

	public class OutputBindingsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OutputBindings");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsOutputBindingParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsOutputBindingsParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//OutputBindings:
		//	lhs=OutputBinding "," rhs=OutputBindings;
		public ParserRule getRule() { return rule; }

		//lhs=OutputBinding "," rhs=OutputBindings
		public Group getGroup() { return cGroup; }

		//lhs=OutputBinding
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//OutputBinding
		public RuleCall getLhsOutputBindingParserRuleCall_0_0() { return cLhsOutputBindingParserRuleCall_0_0; }

		//","
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }

		//rhs=OutputBindings
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//OutputBindings
		public RuleCall getRhsOutputBindingsParserRuleCall_2_0() { return cRhsOutputBindingsParserRuleCall_2_0; }
	}

	public class OutputBindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OutputBinding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActualAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cActualIDTerminalRuleCall_0_0 = (RuleCall)cActualAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFormalAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFormalIDTerminalRuleCall_2_0 = (RuleCall)cFormalAssignment_2.eContents().get(0);
		
		//OutputBinding:
		//	actual=ID "=" formal=ID;
		public ParserRule getRule() { return rule; }

		//actual=ID "=" formal=ID
		public Group getGroup() { return cGroup; }

		//actual=ID
		public Assignment getActualAssignment_0() { return cActualAssignment_0; }

		//ID
		public RuleCall getActualIDTerminalRuleCall_0_0() { return cActualIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//formal=ID
		public Assignment getFormalAssignment_2() { return cFormalAssignment_2; }

		//ID
		public RuleCall getFormalIDTerminalRuleCall_2_0() { return cFormalIDTerminalRuleCall_2_0; }
	}

	public class NodeAttributesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeAttributes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLabelAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPositionAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cApplicationAttributeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//NodeAttributes:
		//	LabelAttribute | PositionAttribute | ApplicationAttribute;
		public ParserRule getRule() { return rule; }

		//LabelAttribute | PositionAttribute | ApplicationAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//LabelAttribute
		public RuleCall getLabelAttributeParserRuleCall_0() { return cLabelAttributeParserRuleCall_0; }

		//PositionAttribute
		public RuleCall getPositionAttributeParserRuleCall_1() { return cPositionAttributeParserRuleCall_1; }

		//ApplicationAttribute
		public RuleCall getApplicationAttributeParserRuleCall_2() { return cApplicationAttributeParserRuleCall_2; }
	}

	public class ExpressionSequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionSequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExpressionSequenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpressionsAssignment_1_1_1.eContents().get(0);
		
		/////////////////////////////////////////////////////
		//// expressions
		/////////////////////////////////////////////////////
		//ExpressionSequence:
		//	{ExpressionSequence} (expressions+=Expression ("," expressions+=Expression)*)?;
		public ParserRule getRule() { return rule; }

		//{ExpressionSequence} (expressions+=Expression ("," expressions+=Expression)*)?
		public Group getGroup() { return cGroup; }

		//{ExpressionSequence}
		public Action getExpressionSequenceAction_0() { return cExpressionSequenceAction_0; }

		//(expressions+=Expression ("," expressions+=Expression)*)?
		public Group getGroup_1() { return cGroup_1; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_0() { return cExpressionsAssignment_1_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_0_0() { return cExpressionsExpressionParserRuleCall_1_0_0; }

		//("," expressions+=Expression)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_1_1() { return cExpressionsAssignment_1_1_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAssignmentOpExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssignmentLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpEqualsSignKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Expression:
		//	assignmentOpExpression ({Assignment.left=current} op="=" right=orExpression)?;
		public ParserRule getRule() { return rule; }

		//assignmentOpExpression ({Assignment.left=current} op="=" right=orExpression)?
		public Group getGroup() { return cGroup; }

		//assignmentOpExpression
		public RuleCall getAssignmentOpExpressionParserRuleCall_0() { return cAssignmentOpExpressionParserRuleCall_0; }

		//({Assignment.left=current} op="=" right=orExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{Assignment.left=current}
		public Action getAssignmentLeftAction_1_0() { return cAssignmentLeftAction_1_0; }

		//op="="
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"="
		public Keyword getOpEqualsSignKeyword_1_1_0() { return cOpEqualsSignKeyword_1_1_0; }

		//right=orExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//orExpression
		public RuleCall getRightOrExpressionParserRuleCall_1_2_0() { return cRightOrExpressionParserRuleCall_1_2_0; }
	}

	public class AssignmentOpExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "assignmentOpExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssignmentOpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpAssignOpParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//assignmentOpExpression:
		//	orExpression ({AssignmentOp.left=current} op=assignOp right=orExpression)?;
		public ParserRule getRule() { return rule; }

		//orExpression ({AssignmentOp.left=current} op=assignOp right=orExpression)?
		public Group getGroup() { return cGroup; }

		//orExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//({AssignmentOp.left=current} op=assignOp right=orExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{AssignmentOp.left=current}
		public Action getAssignmentOpLeftAction_1_0() { return cAssignmentOpLeftAction_1_0; }

		//op=assignOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//assignOp
		public RuleCall getOpAssignOpParserRuleCall_1_1_0() { return cOpAssignOpParserRuleCall_1_1_0; }

		//right=orExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//orExpression
		public RuleCall getRightOrExpressionParserRuleCall_1_2_0() { return cRightOrExpressionParserRuleCall_1_2_0; }
	}

	public class AssignOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "assignOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAsteriskEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cSolidusEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cPercentSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//assignOp:
		//	"+=" | "-=" | "*=" | "/=" | "%=";
		public ParserRule getRule() { return rule; }

		//"+=" | "-=" | "*=" | "/=" | "%="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"+="
		public Keyword getPlusSignEqualsSignKeyword_0() { return cPlusSignEqualsSignKeyword_0; }

		//"-="
		public Keyword getHyphenMinusEqualsSignKeyword_1() { return cHyphenMinusEqualsSignKeyword_1; }

		//"*="
		public Keyword getAsteriskEqualsSignKeyword_2() { return cAsteriskEqualsSignKeyword_2; }

		//"/="
		public Keyword getSolidusEqualsSignKeyword_3() { return cSolidusEqualsSignKeyword_3; }

		//"%="
		public Keyword getPercentSignEqualsSignKeyword_4() { return cPercentSignEqualsSignKeyword_4; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "orExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpVerticalLineVerticalLineKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//orExpression:
		//	andExpression ({OrExp.left=current} op="||" right=orExpression)?;
		public ParserRule getRule() { return rule; }

		//andExpression ({OrExp.left=current} op="||" right=orExpression)?
		public Group getGroup() { return cGroup; }

		//andExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({OrExp.left=current} op="||" right=orExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{OrExp.left=current}
		public Action getOrExpLeftAction_1_0() { return cOrExpLeftAction_1_0; }

		//op="||"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"||"
		public Keyword getOpVerticalLineVerticalLineKeyword_1_1_0() { return cOpVerticalLineVerticalLineKeyword_1_1_0; }

		//right=orExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//orExpression
		public RuleCall getRightOrExpressionParserRuleCall_1_2_0() { return cRightOrExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "andExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAmpersandAmpersandKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//andExpression:
		//	relationalExpression ({AndExp.left=current} op="&&" right=andExpression)?;
		public ParserRule getRule() { return rule; }

		//relationalExpression ({AndExp.left=current} op="&&" right=andExpression)?
		public Group getGroup() { return cGroup; }

		//relationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({AndExp.left=current} op="&&" right=andExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{AndExp.left=current}
		public Action getAndExpLeftAction_1_0() { return cAndExpLeftAction_1_0; }

		//op="&&"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"&&"
		public Keyword getOpAmpersandAmpersandKeyword_1_1_0() { return cOpAmpersandAmpersandKeyword_1_1_0; }

		//right=andExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//andExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "relationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationalExpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpRelOpsParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//relationalExpression:
		//	additiveExpression ({RelationalExp.left=current} op=relOps right=relationalExpression)?;
		public ParserRule getRule() { return rule; }

		//additiveExpression ({RelationalExp.left=current} op=relOps right=relationalExpression)?
		public Group getGroup() { return cGroup; }

		//additiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({RelationalExp.left=current} op=relOps right=relationalExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{RelationalExp.left=current}
		public Action getRelationalExpLeftAction_1_0() { return cRelationalExpLeftAction_1_0; }

		//op=relOps
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//relOps
		public RuleCall getOpRelOpsParserRuleCall_1_1_0() { return cOpRelOpsParserRuleCall_1_1_0; }

		//right=relationalExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//relationalExpression
		public RuleCall getRightRelationalExpressionParserRuleCall_1_2_0() { return cRightRelationalExpressionParserRuleCall_1_2_0; }
	}

	public class RelOpsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "relOps");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGreaterThanSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLessThanSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cGreaterThanSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		
		//relOps:
		//	"!=" | "==" | "<=" | "<>" | ">=" | "<" | ">";
		public ParserRule getRule() { return rule; }

		//"!=" | "==" | "<=" | "<>" | ">=" | "<" | ">"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_0() { return cExclamationMarkEqualsSignKeyword_0; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_1() { return cEqualsSignEqualsSignKeyword_1; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_2() { return cLessThanSignEqualsSignKeyword_2; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_3() { return cLessThanSignGreaterThanSignKeyword_3; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_4() { return cGreaterThanSignEqualsSignKeyword_4; }

		//"<"
		public Keyword getLessThanSignKeyword_5() { return cLessThanSignKeyword_5; }

		//">"
		public Keyword getGreaterThanSignKeyword_6() { return cGreaterThanSignKeyword_6; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "additiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditiveExpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpArithOpsParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//additiveExpression:
		//	multiplicativeExpression ({AdditiveExp.left=current} op=arithOps right=additiveExpression)?;
		public ParserRule getRule() { return rule; }

		//multiplicativeExpression ({AdditiveExp.left=current} op=arithOps right=additiveExpression)?
		public Group getGroup() { return cGroup; }

		//multiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({AdditiveExp.left=current} op=arithOps right=additiveExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{AdditiveExp.left=current}
		public Action getAdditiveExpLeftAction_1_0() { return cAdditiveExpLeftAction_1_0; }

		//op=arithOps
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//arithOps
		public RuleCall getOpArithOpsParserRuleCall_1_1_0() { return cOpArithOpsParserRuleCall_1_1_0; }

		//right=additiveExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//additiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_2_0() { return cRightAdditiveExpressionParserRuleCall_1_2_0; }
	}

	public class ArithOpsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "arithOps");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//arithOps:
		//	"+" | "-";
		public ParserRule getRule() { return rule; }

		//"+" | "-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"+"
		public Keyword getPlusSignKeyword_0() { return cPlusSignKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "multiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicativeExpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpMultOpsParserRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//multiplicativeExpression:
		//	unaryExpression ({MultiplicativeExp.left=current} op=multOps right=multiplicativeExpression)?;
		public ParserRule getRule() { return rule; }

		//unaryExpression ({MultiplicativeExp.left=current} op=multOps right=multiplicativeExpression)?
		public Group getGroup() { return cGroup; }

		//unaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }

		//({MultiplicativeExp.left=current} op=multOps right=multiplicativeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{MultiplicativeExp.left=current}
		public Action getMultiplicativeExpLeftAction_1_0() { return cMultiplicativeExpLeftAction_1_0; }

		//op=multOps
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//multOps
		public RuleCall getOpMultOpsParserRuleCall_1_1_0() { return cOpMultOpsParserRuleCall_1_1_0; }

		//right=multiplicativeExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//multiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultOpsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "multOps");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//multOps:
		//	"*" | "/";
		public ParserRule getRule() { return rule; }

		//"*" | "/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTermExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cOpAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOpUnaryOpsParserRuleCall_1_0_0 = (RuleCall)cOpAssignment_1_0.eContents().get(0);
		private final Assignment cExprAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExprTermExpressionParserRuleCall_1_1_0 = (RuleCall)cExprAssignment_1_1.eContents().get(0);
		
		//unaryExpression:
		//	TermExpression | op=unaryOps expr=TermExpression;
		public ParserRule getRule() { return rule; }

		//TermExpression | op=unaryOps expr=TermExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//TermExpression
		public RuleCall getTermExpressionParserRuleCall_0() { return cTermExpressionParserRuleCall_0; }

		//op=unaryOps expr=TermExpression
		public Group getGroup_1() { return cGroup_1; }

		//op=unaryOps
		public Assignment getOpAssignment_1_0() { return cOpAssignment_1_0; }

		//unaryOps
		public RuleCall getOpUnaryOpsParserRuleCall_1_0_0() { return cOpUnaryOpsParserRuleCall_1_0_0; }

		//expr=TermExpression
		public Assignment getExprAssignment_1_1() { return cExprAssignment_1_1; }

		//TermExpression
		public RuleCall getExprTermExpressionParserRuleCall_1_1_0() { return cExprTermExpressionParserRuleCall_1_1_0; }
	}

	public class UnaryOpsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unaryOps");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//unaryOps:
		//	"-" | "!";
		public ParserRule getRule() { return rule; }

		//"-" | "!"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1() { return cExclamationMarkKeyword_1; }
	}

	public class OperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Operator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpOperatorNameParserRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSequenceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSequenceExpressionSequenceParserRuleCall_2_0 = (RuleCall)cSequenceAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Operator:
		//	op=OperatorName "(" sequence=ExpressionSequence ")";
		public ParserRule getRule() { return rule; }

		//op=OperatorName "(" sequence=ExpressionSequence ")"
		public Group getGroup() { return cGroup; }

		//op=OperatorName
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }

		//OperatorName
		public RuleCall getOpOperatorNameParserRuleCall_0_0() { return cOpOperatorNameParserRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//sequence=ExpressionSequence
		public Assignment getSequenceAssignment_2() { return cSequenceAssignment_2; }

		//ExpressionSequence
		public RuleCall getSequenceExpressionSequenceParserRuleCall_2_0() { return cSequenceExpressionSequenceParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class TermExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TermExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTermLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOperatorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TermExpression:
		//	TermLiteral | Operator;
		public ParserRule getRule() { return rule; }

		//TermLiteral | Operator
		public Alternatives getAlternatives() { return cAlternatives; }

		//TermLiteral
		public RuleCall getTermLiteralParserRuleCall_0() { return cTermLiteralParserRuleCall_0; }

		//Operator
		public RuleCall getOperatorParserRuleCall_1() { return cOperatorParserRuleCall_1; }
	}

	public class TermLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TermLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVarRefAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cIntegerLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBooleanLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cStringLiteralAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_3_1_0 = (RuleCall)cValueAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cDoubleLiteralAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cValueDOUBLETerminalRuleCall_4_1_0 = (RuleCall)cValueAssignment_4_1.eContents().get(0);
		
		//TermLiteral:
		//	{VarRef} value=ID | {IntegerLiteral} value=INT | {BooleanLiteral} value=BOOLEAN | {StringLiteral} value=STRING |
		//	{DoubleLiteral} value=DOUBLE;
		public ParserRule getRule() { return rule; }

		//{VarRef} value=ID | {IntegerLiteral} value=INT | {BooleanLiteral} value=BOOLEAN | {StringLiteral} value=STRING |
		//{DoubleLiteral} value=DOUBLE
		public Alternatives getAlternatives() { return cAlternatives; }

		//{VarRef} value=ID
		public Group getGroup_0() { return cGroup_0; }

		//{VarRef}
		public Action getVarRefAction_0_0() { return cVarRefAction_0_0; }

		//value=ID
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }

		//ID
		public RuleCall getValueIDTerminalRuleCall_0_1_0() { return cValueIDTerminalRuleCall_0_1_0; }

		//{IntegerLiteral} value=INT
		public Group getGroup_1() { return cGroup_1; }

		//{IntegerLiteral}
		public Action getIntegerLiteralAction_1_0() { return cIntegerLiteralAction_1_0; }

		//value=INT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_1_0() { return cValueINTTerminalRuleCall_1_1_0; }

		//{BooleanLiteral} value=BOOLEAN
		public Group getGroup_2() { return cGroup_2; }

		//{BooleanLiteral}
		public Action getBooleanLiteralAction_2_0() { return cBooleanLiteralAction_2_0; }

		//value=BOOLEAN
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }

		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_2_1_0() { return cValueBOOLEANTerminalRuleCall_2_1_0; }

		//{StringLiteral} value=STRING
		public Group getGroup_3() { return cGroup_3; }

		//{StringLiteral}
		public Action getStringLiteralAction_3_0() { return cStringLiteralAction_3_0; }

		//value=STRING
		public Assignment getValueAssignment_3_1() { return cValueAssignment_3_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_3_1_0() { return cValueSTRINGTerminalRuleCall_3_1_0; }

		//{DoubleLiteral} value=DOUBLE
		public Group getGroup_4() { return cGroup_4; }

		//{DoubleLiteral}
		public Action getDoubleLiteralAction_4_0() { return cDoubleLiteralAction_4_0; }

		//value=DOUBLE
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }

		//DOUBLE
		public RuleCall getValueDOUBLETerminalRuleCall_4_1_0() { return cValueDOUBLETerminalRuleCall_4_1_0; }
	}

	public class OperatorNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperatorName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTruncateKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNormalKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLogNormalKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cBetaKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGammaKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExponentialKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cWeibullKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cUniformKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cTriangularKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cPERTKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cBinomialKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cPoissonKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cNegativeBinomialKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cGeometricKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cDistributionKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cNoisyORKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cMinKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cMaxKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cLogKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLog2Keyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cLog10Keyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cExpKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cSinKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cCosKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cTanKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cSinhKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cCoshKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cTanhKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cSqrtKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cAbsKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cFloorKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cCeilKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Keyword cModKeyword_32 = (Keyword)cAlternatives.eContents().get(32);
		private final Keyword cIfKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cAndKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cOrKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		private final Keyword cNotKeyword_36 = (Keyword)cAlternatives.eContents().get(36);
		
		/////////////////////////////////////////////////////	
		//// pending validations, for Java editor callbacks	
		/////////////////////////////////////////////////////
		//// TODO create a validation rule that states attribute is only allowed for discrete nodes
		//// TODO subtype attribute only for discrete (chance or decision) node
		//// TODO state_values attribute only for nodes of type number or interval
		//// TODO state_values attribute must appear after subtype and states attributes
		//// TODO state_values if subtype number list length same as states list
		//// TODO state_values if subtype interval list length one greater than states list
		//// TODO potential graph children must be >0 if parents used
		//// TODO chance, decision, and utility nodes can only have chance and decision nodes as parents
		//// TODO discrete nodes can only have discrete nodes as parents
		//// TODO a node must not be referenced in a potential specification before it has been defined by a node, decision, utility, or function specification
		//// TODO mean value of normal distribution must be linear function of continuous graph parents, each term must be numeric constant, name of continuous parent, or constant followed by '*' followed by name of continuous parent
		//// TODO formal input name must refer to a node listed in the inputs attribute of the class with name
		//// TODO the node referred to by the actual input name must be defined somewhere in the class containing the class instance
		//OperatorName:
		//	"truncate" | "Normal" | "LogNormal" | "Beta" | "Gamma" | "Exponential" | "Weibull" | "Uniform" | "Triangular" | "PERT"
		//	| "Binomial" | "Poisson" | "NegativeBinomial" | "Geometric" | "Distribution" | "NoisyOR" | "min" | "max" | "log" |
		//	"log2" | "log10" | "exp" | "sin" | "cos" | "tan" | "sinh" | "cosh" | "tanh" | "sqrt" | "abs" | "floor" | "ceil" |
		//	"mod" | "if" | "and" | "or" | "not";
		public ParserRule getRule() { return rule; }

		//"truncate" | "Normal" | "LogNormal" | "Beta" | "Gamma" | "Exponential" | "Weibull" | "Uniform" | "Triangular" | "PERT" |
		//"Binomial" | "Poisson" | "NegativeBinomial" | "Geometric" | "Distribution" | "NoisyOR" | "min" | "max" | "log" | "log2"
		//| "log10" | "exp" | "sin" | "cos" | "tan" | "sinh" | "cosh" | "tanh" | "sqrt" | "abs" | "floor" | "ceil" | "mod" | "if"
		//| "and" | "or" | "not"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"truncate"
		public Keyword getTruncateKeyword_0() { return cTruncateKeyword_0; }

		//"Normal"
		public Keyword getNormalKeyword_1() { return cNormalKeyword_1; }

		//"LogNormal"
		public Keyword getLogNormalKeyword_2() { return cLogNormalKeyword_2; }

		//"Beta"
		public Keyword getBetaKeyword_3() { return cBetaKeyword_3; }

		//"Gamma"
		public Keyword getGammaKeyword_4() { return cGammaKeyword_4; }

		//"Exponential"
		public Keyword getExponentialKeyword_5() { return cExponentialKeyword_5; }

		//"Weibull"
		public Keyword getWeibullKeyword_6() { return cWeibullKeyword_6; }

		//"Uniform"
		public Keyword getUniformKeyword_7() { return cUniformKeyword_7; }

		//"Triangular"
		public Keyword getTriangularKeyword_8() { return cTriangularKeyword_8; }

		//"PERT"
		public Keyword getPERTKeyword_9() { return cPERTKeyword_9; }

		//"Binomial"
		public Keyword getBinomialKeyword_10() { return cBinomialKeyword_10; }

		//"Poisson"
		public Keyword getPoissonKeyword_11() { return cPoissonKeyword_11; }

		//"NegativeBinomial"
		public Keyword getNegativeBinomialKeyword_12() { return cNegativeBinomialKeyword_12; }

		//"Geometric"
		public Keyword getGeometricKeyword_13() { return cGeometricKeyword_13; }

		//"Distribution"
		public Keyword getDistributionKeyword_14() { return cDistributionKeyword_14; }

		//"NoisyOR"
		public Keyword getNoisyORKeyword_15() { return cNoisyORKeyword_15; }

		//"min"
		public Keyword getMinKeyword_16() { return cMinKeyword_16; }

		//"max"
		public Keyword getMaxKeyword_17() { return cMaxKeyword_17; }

		//"log"
		public Keyword getLogKeyword_18() { return cLogKeyword_18; }

		//"log2"
		public Keyword getLog2Keyword_19() { return cLog2Keyword_19; }

		//"log10"
		public Keyword getLog10Keyword_20() { return cLog10Keyword_20; }

		//"exp"
		public Keyword getExpKeyword_21() { return cExpKeyword_21; }

		//"sin"
		public Keyword getSinKeyword_22() { return cSinKeyword_22; }

		//"cos"
		public Keyword getCosKeyword_23() { return cCosKeyword_23; }

		//"tan"
		public Keyword getTanKeyword_24() { return cTanKeyword_24; }

		//"sinh"
		public Keyword getSinhKeyword_25() { return cSinhKeyword_25; }

		//"cosh"
		public Keyword getCoshKeyword_26() { return cCoshKeyword_26; }

		//"tanh"
		public Keyword getTanhKeyword_27() { return cTanhKeyword_27; }

		//"sqrt"
		public Keyword getSqrtKeyword_28() { return cSqrtKeyword_28; }

		//"abs"
		public Keyword getAbsKeyword_29() { return cAbsKeyword_29; }

		//"floor"
		public Keyword getFloorKeyword_30() { return cFloorKeyword_30; }

		//"ceil"
		public Keyword getCeilKeyword_31() { return cCeilKeyword_31; }

		//"mod"
		public Keyword getModKeyword_32() { return cModKeyword_32; }

		//"if"
		public Keyword getIfKeyword_33() { return cIfKeyword_33; }

		//"and"
		public Keyword getAndKeyword_34() { return cAndKeyword_34; }

		//"or"
		public Keyword getOrKeyword_35() { return cOrKeyword_35; }

		//"not"
		public Keyword getNotKeyword_36() { return cNotKeyword_36; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tBOOLEAN;
	private TerminalRule tID;
	private TerminalRule tINT;
	private TerminalRule tDOUBLE;
	private TerminalRule tSTRING;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tANY_OTHER;
	private IntegerElements pInteger;
	private DomainDefinitionElements pDomainDefinition;
	private DomainHeaderElements pDomainHeader;
	private DomainElementElements pDomainElement;
	private AttributeElements pAttribute;
	private BasicNodeElements pBasicNode;
	private BasicNodeKeywordElements pBasicNodeKeyword;
	private StatesAttributeElements pStatesAttribute;
	private LabelAttributeElements pLabelAttribute;
	private PositionAttributeElements pPositionAttribute;
	private SubtypeAttributeElements pSubtypeAttribute;
	private StateValuesAttributeElements pStateValuesAttribute;
	private ApplicationAttributeElements pApplicationAttribute;
	private NodeSizeAttributeElements pNodeSizeAttribute;
	private PotentialElements pPotential;
	private PotentialGraphElements pPotentialGraph;
	private PotentialModelElements pPotentialModel;
	private PotentialAttributeElements pPotentialAttribute;
	private PotentialDataAttributeElements pPotentialDataAttribute;
	private MatrixRowElements pMatrixRow;
	private List5Elements pList5;
	private List4Elements pList4;
	private List3Elements pList3;
	private List2Elements pList2;
	private List1Elements pList1;
	private MeanExpressionElements pMeanExpression;
	private MeanTermElements pMeanTerm;
	private PotentialTableAttributeElements pPotentialTableAttribute;
	private ModelNodesAttributeElements pModelNodesAttribute;
	private SamplesAttributeElements pSamplesAttribute;
	private ModelDataAttributeElements pModelDataAttribute;
	private ClassDefinitionElements pClassDefinition;
	private ClassElementElements pClassElement;
	private ClassInstanceElements pClassInstance;
	private InputBindingsElements pInputBindings;
	private InputBindingElements pInputBinding;
	private OutputBindingsElements pOutputBindings;
	private OutputBindingElements pOutputBinding;
	private NodeAttributesElements pNodeAttributes;
	private ExpressionSequenceElements pExpressionSequence;
	private ExpressionElements pExpression;
	private AssignmentOpExpressionElements pAssignmentOpExpression;
	private AssignOpElements pAssignOp;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private RelationalExpressionElements pRelationalExpression;
	private RelOpsElements pRelOps;
	private AdditiveExpressionElements pAdditiveExpression;
	private ArithOpsElements pArithOps;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private MultOpsElements pMultOps;
	private UnaryExpressionElements pUnaryExpression;
	private UnaryOpsElements pUnaryOps;
	private OperatorElements pOperator;
	private TermExpressionElements pTermExpression;
	private TermLiteralElements pTermLiteral;
	private OperatorNameElements pOperatorName;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public NetDSLGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//Model:
	//	domain=DomainDefinition?;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	////terminal DOUBLE returns ecore::EDouble
	////	: '-'? ('0'..'9')+ ('.' ('0'..'9')+ (('e'|'E') ('-')? ('0'..'9')+)?)?;
	//// terminal INT returns ecore::EInt: ('0'..'9')+ ;
	//terminal INT returns ecore::EInt:
	//	"0" | "1".."9" "0".."9"*;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal DOUBLE returns ecore::EDouble:
	//	"1".."9" "0".."9"* ("." "0".."9"+)? (("E" | "e") ("+" | "-")? "0".."9"+)? | "0" ("." "0".."9"+)? (("E" | "e") ("+" |
	//	"-")? "0".."9"+)?;
	public TerminalRule getDOUBLERule() {
		return (tDOUBLE != null) ? tDOUBLE : (tDOUBLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOUBLE"));
	} 

	////terminal STRING :
	////'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
	////"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"; 
	//terminal STRING:
	//	"\""->"\"";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//	"%" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//// terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ; 
	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	////DOUBLE: INT '.' (EXT_INT | INT);
	////terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//Integer:
	//	i=INT;
	public IntegerElements getIntegerAccess() {
		return (pInteger != null) ? pInteger : (pInteger = new IntegerElements());
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}

	//DomainDefinition:
	//	header=DomainHeader elements+=DomainElement*;
	public DomainDefinitionElements getDomainDefinitionAccess() {
		return (pDomainDefinition != null) ? pDomainDefinition : (pDomainDefinition = new DomainDefinitionElements());
	}
	
	public ParserRule getDomainDefinitionRule() {
		return getDomainDefinitionAccess().getRule();
	}

	//DomainHeader:
	//	{DomainHeader} "net" "{" attributes+=Attribute* "}";
	public DomainHeaderElements getDomainHeaderAccess() {
		return (pDomainHeader != null) ? pDomainHeader : (pDomainHeader = new DomainHeaderElements());
	}
	
	public ParserRule getDomainHeaderRule() {
		return getDomainHeaderAccess().getRule();
	}

	//DomainElement:
	//	BasicNode | Potential | ClassDefinition;
	public DomainElementElements getDomainElementAccess() {
		return (pDomainElement != null) ? pDomainElement : (pDomainElement = new DomainElementElements());
	}
	
	public ParserRule getDomainElementRule() {
		return getDomainElementAccess().getRule();
	}

	//Attribute:
	//	StatesAttribute | LabelAttribute | PositionAttribute | SubtypeAttribute | StateValuesAttribute | ApplicationAttribute
	//	| NodeSizeAttribute;
	public AttributeElements getAttributeAccess() {
		return (pAttribute != null) ? pAttribute : (pAttribute = new AttributeElements());
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	//BasicNode:
	//	keyword=BasicNodeKeyword id=ID? "{" attributes+=Attribute* "}";
	public BasicNodeElements getBasicNodeAccess() {
		return (pBasicNode != null) ? pBasicNode : (pBasicNode = new BasicNodeElements());
	}
	
	public ParserRule getBasicNodeRule() {
		return getBasicNodeAccess().getRule();
	}

	//BasicNodeKeyword:
	//	("discrete" | "continuous")? "node" | "decision" | "utility" | "function";
	public BasicNodeKeywordElements getBasicNodeKeywordAccess() {
		return (pBasicNodeKeyword != null) ? pBasicNodeKeyword : (pBasicNodeKeyword = new BasicNodeKeywordElements());
	}
	
	public ParserRule getBasicNodeKeywordRule() {
		return getBasicNodeKeywordAccess().getRule();
	}

	//StatesAttribute:
	//	{StatesAttribute} "states" "=" "(" states+=STRING* ")" ";";
	public StatesAttributeElements getStatesAttributeAccess() {
		return (pStatesAttribute != null) ? pStatesAttribute : (pStatesAttribute = new StatesAttributeElements());
	}
	
	public ParserRule getStatesAttributeRule() {
		return getStatesAttributeAccess().getRule();
	}

	//LabelAttribute:
	//	"label" "=" value=STRING ";";
	public LabelAttributeElements getLabelAttributeAccess() {
		return (pLabelAttribute != null) ? pLabelAttribute : (pLabelAttribute = new LabelAttributeElements());
	}
	
	public ParserRule getLabelAttributeRule() {
		return getLabelAttributeAccess().getRule();
	}

	//PositionAttribute:
	//	"position" "=" "(" {IntegerLiteral} x=Integer y=Integer ")" ";";
	public PositionAttributeElements getPositionAttributeAccess() {
		return (pPositionAttribute != null) ? pPositionAttribute : (pPositionAttribute = new PositionAttributeElements());
	}
	
	public ParserRule getPositionAttributeRule() {
		return getPositionAttributeAccess().getRule();
	}

	//SubtypeAttribute:
	//	"subtype" "=" subtype=("label" | "boolean" | "number" | "interval") ";";
	public SubtypeAttributeElements getSubtypeAttributeAccess() {
		return (pSubtypeAttribute != null) ? pSubtypeAttribute : (pSubtypeAttribute = new SubtypeAttributeElements());
	}
	
	public ParserRule getSubtypeAttributeRule() {
		return getSubtypeAttributeAccess().getRule();
	}

	//StateValuesAttribute:
	//	"state_values" "=" "(" numbers+=INT+ ")" ";";
	public StateValuesAttributeElements getStateValuesAttributeAccess() {
		return (pStateValuesAttribute != null) ? pStateValuesAttribute : (pStateValuesAttribute = new StateValuesAttributeElements());
	}
	
	public ParserRule getStateValuesAttributeRule() {
		return getStateValuesAttributeAccess().getRule();
	}

	//ApplicationAttribute:
	//	key=ID "=" value=STRING ";";
	public ApplicationAttributeElements getApplicationAttributeAccess() {
		return (pApplicationAttribute != null) ? pApplicationAttribute : (pApplicationAttribute = new ApplicationAttributeElements());
	}
	
	public ParserRule getApplicationAttributeRule() {
		return getApplicationAttributeAccess().getRule();
	}

	//// global magic for HUGIN GUI
	//NodeSizeAttribute:
	//	"node_size" "=" "(" width=INT height=INT ")" ";";
	public NodeSizeAttributeElements getNodeSizeAttributeAccess() {
		return (pNodeSizeAttribute != null) ? pNodeSizeAttribute : (pNodeSizeAttribute = new NodeSizeAttributeElements());
	}
	
	public ParserRule getNodeSizeAttributeRule() {
		return getNodeSizeAttributeAccess().getRule();
	}

	//Potential:
	//	"potential" graph=PotentialGraph model=PotentialModel;
	public PotentialElements getPotentialAccess() {
		return (pPotential != null) ? pPotential : (pPotential = new PotentialElements());
	}
	
	public ParserRule getPotentialRule() {
		return getPotentialAccess().getRule();
	}

	//PotentialGraph:
	//	{PotentialGraph} "(" children+=ID* ("|" parents+=ID*)? ")";
	public PotentialGraphElements getPotentialGraphAccess() {
		return (pPotentialGraph != null) ? pPotentialGraph : (pPotentialGraph = new PotentialGraphElements());
	}
	
	public ParserRule getPotentialGraphRule() {
		return getPotentialGraphAccess().getRule();
	}

	//PotentialModel:
	//	{PotentialModel} "{" attributes+=PotentialAttribute* "}";
	public PotentialModelElements getPotentialModelAccess() {
		return (pPotentialModel != null) ? pPotentialModel : (pPotentialModel = new PotentialModelElements());
	}
	
	public ParserRule getPotentialModelRule() {
		return getPotentialModelAccess().getRule();
	}

	//PotentialAttribute:
	//	PotentialDataAttribute | // TODO fragile
	//	PotentialTableAttribute;
	public PotentialAttributeElements getPotentialAttributeAccess() {
		return (pPotentialAttribute != null) ? pPotentialAttribute : (pPotentialAttribute = new PotentialAttributeElements());
	}
	
	public ParserRule getPotentialAttributeRule() {
		return getPotentialAttributeAccess().getRule();
	}

	//PotentialDataAttribute:
	//	{PotentialDataAttribute} "data" "=" data=MatrixRow ";";
	public PotentialDataAttributeElements getPotentialDataAttributeAccess() {
		return (pPotentialDataAttribute != null) ? pPotentialDataAttribute : (pPotentialDataAttribute = new PotentialDataAttributeElements());
	}
	
	public ParserRule getPotentialDataAttributeRule() {
		return getPotentialDataAttributeAccess().getRule();
	}

	//// tough to do arbitrary nesting in xtext, so do reasonably deep rules
	//// validation rules should check content patterns
	//MatrixRow:
	//	{MatrixRow} // trying for big enough to handle barley
	//	r5+=List5+ | {MatrixRow} // '(' '(' '(' r31+=List1+ ')' '(' r32+=List1+ ')' '(' r33+=List1+ ')' ')' ')'
	//	r4+=List4+ | {MatrixRow} //'(' '(' r21+=List+ ')' '(' r22+=List+ ')' ')'
	//	r3+=List3+ | {MatrixRow} // '(' r11+=List+ ')'
	//	r2+=List2+ | {MatrixRow} r1=List1;
	public MatrixRowElements getMatrixRowAccess() {
		return (pMatrixRow != null) ? pMatrixRow : (pMatrixRow = new MatrixRowElements());
	}
	
	public ParserRule getMatrixRowRule() {
		return getMatrixRowAccess().getRule();
	}

	//List5 returns MatrixRow:
	//	{List5} "(" list+=List4+ ")";
	public List5Elements getList5Access() {
		return (pList5 != null) ? pList5 : (pList5 = new List5Elements());
	}
	
	public ParserRule getList5Rule() {
		return getList5Access().getRule();
	}

	//List4 returns MatrixRow:
	//	{List4} "(" list+=List3+ ")";
	public List4Elements getList4Access() {
		return (pList4 != null) ? pList4 : (pList4 = new List4Elements());
	}
	
	public ParserRule getList4Rule() {
		return getList4Access().getRule();
	}

	//List3 returns MatrixRow:
	//	{List3} "(" list+=List2+ ")";
	public List3Elements getList3Access() {
		return (pList3 != null) ? pList3 : (pList3 = new List3Elements());
	}
	
	public ParserRule getList3Rule() {
		return getList3Access().getRule();
	}

	//List2 returns MatrixRow:
	//	{List2} "(" list+=List1+ ")";
	public List2Elements getList2Access() {
		return (pList2 != null) ? pList2 : (pList2 = new List2Elements());
	}
	
	public ParserRule getList2Rule() {
		return getList2Access().getRule();
	}

	//// TODO add normal distribution as an expression operation
	//List1 returns MatrixRow:
	//	{List1} "(" items+=unaryExpression* ")";
	public List1Elements getList1Access() {
		return (pList1 != null) ? pList1 : (pList1 = new List1Elements());
	}
	
	public ParserRule getList1Rule() {
		return getList1Access().getRule();
	}

	//// TODO redefine as an operator so it matches unary expressions
	////NormalDistribution 
	////	: 'normal' '(' mean=MeanExpression ',' variance=DOUBLE ')'
	////	;
	//MeanExpression:
	//	MeanTerm ("+" MeanTerm)*;
	public MeanExpressionElements getMeanExpressionAccess() {
		return (pMeanExpression != null) ? pMeanExpression : (pMeanExpression = new MeanExpressionElements());
	}
	
	public ParserRule getMeanExpressionRule() {
		return getMeanExpressionAccess().getRule();
	}

	//MeanTerm:
	//	DOUBLE | DOUBLE "*" ID | ID;
	public MeanTermElements getMeanTermAccess() {
		return (pMeanTerm != null) ? pMeanTerm : (pMeanTerm = new MeanTermElements());
	}
	
	public ParserRule getMeanTermRule() {
		return getMeanTermAccess().getRule();
	}

	//PotentialTableAttribute:
	//	nodes=ModelNodesAttribute samples=SamplesAttribute? data=ModelDataAttribute;
	public PotentialTableAttributeElements getPotentialTableAttributeAccess() {
		return (pPotentialTableAttribute != null) ? pPotentialTableAttribute : (pPotentialTableAttribute = new PotentialTableAttributeElements());
	}
	
	public ParserRule getPotentialTableAttributeRule() {
		return getPotentialTableAttributeAccess().getRule();
	}

	//ModelNodesAttribute:
	//	{ModelNodesAttribute} "model_nodes" "=" "(" configurations+=ID* ")" ";";
	public ModelNodesAttributeElements getModelNodesAttributeAccess() {
		return (pModelNodesAttribute != null) ? pModelNodesAttribute : (pModelNodesAttribute = new ModelNodesAttributeElements());
	}
	
	public ParserRule getModelNodesAttributeRule() {
		return getModelNodesAttributeAccess().getRule();
	}

	//SamplesAttribute:
	//	"samples_per_interval" "=" value=INT ";";
	public SamplesAttributeElements getSamplesAttributeAccess() {
		return (pSamplesAttribute != null) ? pSamplesAttribute : (pSamplesAttribute = new SamplesAttributeElements());
	}
	
	public ParserRule getSamplesAttributeRule() {
		return getSamplesAttributeAccess().getRule();
	}

	//ModelDataAttribute:
	//	{ModelDataAttribute} "model_data" "=" "(" sequence=ExpressionSequence ")" ";";
	public ModelDataAttributeElements getModelDataAttributeAccess() {
		return (pModelDataAttribute != null) ? pModelDataAttribute : (pModelDataAttribute = new ModelDataAttributeElements());
	}
	
	public ParserRule getModelDataAttributeRule() {
		return getModelDataAttributeAccess().getRule();
	}

	/////////////////////////////////////////////////////
	//// classes
	/////////////////////////////////////////////////////
	//ClassDefinition:
	//	"class" name=ID "{" elements+=ClassElement* "}";
	public ClassDefinitionElements getClassDefinitionAccess() {
		return (pClassDefinition != null) ? pClassDefinition : (pClassDefinition = new ClassDefinitionElements());
	}
	
	public ParserRule getClassDefinitionRule() {
		return getClassDefinitionAccess().getRule();
	}

	//ClassElement:
	//	DomainElement | Attribute | ClassInstance;
	public ClassElementElements getClassElementAccess() {
		return (pClassElement != null) ? pClassElement : (pClassElement = new ClassElementElements());
	}
	
	public ParserRule getClassElementRule() {
		return getClassElementAccess().getRule();
	}

	//ClassInstance:
	//	"instance" instanceName=ID ":" className=ID "(" input=InputBindings? (";" output=OutputBindings)? ")" "{"
	//	attributes=NodeAttributes "}";
	public ClassInstanceElements getClassInstanceAccess() {
		return (pClassInstance != null) ? pClassInstance : (pClassInstance = new ClassInstanceElements());
	}
	
	public ParserRule getClassInstanceRule() {
		return getClassInstanceAccess().getRule();
	}

	//InputBindings:
	//	lhs=InputBinding "," rhs=InputBindings;
	public InputBindingsElements getInputBindingsAccess() {
		return (pInputBindings != null) ? pInputBindings : (pInputBindings = new InputBindingsElements());
	}
	
	public ParserRule getInputBindingsRule() {
		return getInputBindingsAccess().getRule();
	}

	//InputBinding:
	//	formal=ID "=" actual=ID;
	public InputBindingElements getInputBindingAccess() {
		return (pInputBinding != null) ? pInputBinding : (pInputBinding = new InputBindingElements());
	}
	
	public ParserRule getInputBindingRule() {
		return getInputBindingAccess().getRule();
	}

	//OutputBindings:
	//	lhs=OutputBinding "," rhs=OutputBindings;
	public OutputBindingsElements getOutputBindingsAccess() {
		return (pOutputBindings != null) ? pOutputBindings : (pOutputBindings = new OutputBindingsElements());
	}
	
	public ParserRule getOutputBindingsRule() {
		return getOutputBindingsAccess().getRule();
	}

	//OutputBinding:
	//	actual=ID "=" formal=ID;
	public OutputBindingElements getOutputBindingAccess() {
		return (pOutputBinding != null) ? pOutputBinding : (pOutputBinding = new OutputBindingElements());
	}
	
	public ParserRule getOutputBindingRule() {
		return getOutputBindingAccess().getRule();
	}

	//NodeAttributes:
	//	LabelAttribute | PositionAttribute | ApplicationAttribute;
	public NodeAttributesElements getNodeAttributesAccess() {
		return (pNodeAttributes != null) ? pNodeAttributes : (pNodeAttributes = new NodeAttributesElements());
	}
	
	public ParserRule getNodeAttributesRule() {
		return getNodeAttributesAccess().getRule();
	}

	/////////////////////////////////////////////////////
	//// expressions
	/////////////////////////////////////////////////////
	//ExpressionSequence:
	//	{ExpressionSequence} (expressions+=Expression ("," expressions+=Expression)*)?;
	public ExpressionSequenceElements getExpressionSequenceAccess() {
		return (pExpressionSequence != null) ? pExpressionSequence : (pExpressionSequence = new ExpressionSequenceElements());
	}
	
	public ParserRule getExpressionSequenceRule() {
		return getExpressionSequenceAccess().getRule();
	}

	//Expression:
	//	assignmentOpExpression ({Assignment.left=current} op="=" right=orExpression)?;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//assignmentOpExpression:
	//	orExpression ({AssignmentOp.left=current} op=assignOp right=orExpression)?;
	public AssignmentOpExpressionElements getAssignmentOpExpressionAccess() {
		return (pAssignmentOpExpression != null) ? pAssignmentOpExpression : (pAssignmentOpExpression = new AssignmentOpExpressionElements());
	}
	
	public ParserRule getAssignmentOpExpressionRule() {
		return getAssignmentOpExpressionAccess().getRule();
	}

	//assignOp:
	//	"+=" | "-=" | "*=" | "/=" | "%=";
	public AssignOpElements getAssignOpAccess() {
		return (pAssignOp != null) ? pAssignOp : (pAssignOp = new AssignOpElements());
	}
	
	public ParserRule getAssignOpRule() {
		return getAssignOpAccess().getRule();
	}

	//orExpression:
	//	andExpression ({OrExp.left=current} op="||" right=orExpression)?;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//andExpression:
	//	relationalExpression ({AndExp.left=current} op="&&" right=andExpression)?;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//relationalExpression:
	//	additiveExpression ({RelationalExp.left=current} op=relOps right=relationalExpression)?;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//relOps:
	//	"!=" | "==" | "<=" | "<>" | ">=" | "<" | ">";
	public RelOpsElements getRelOpsAccess() {
		return (pRelOps != null) ? pRelOps : (pRelOps = new RelOpsElements());
	}
	
	public ParserRule getRelOpsRule() {
		return getRelOpsAccess().getRule();
	}

	//additiveExpression:
	//	multiplicativeExpression ({AdditiveExp.left=current} op=arithOps right=additiveExpression)?;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//arithOps:
	//	"+" | "-";
	public ArithOpsElements getArithOpsAccess() {
		return (pArithOps != null) ? pArithOps : (pArithOps = new ArithOpsElements());
	}
	
	public ParserRule getArithOpsRule() {
		return getArithOpsAccess().getRule();
	}

	//multiplicativeExpression:
	//	unaryExpression ({MultiplicativeExp.left=current} op=multOps right=multiplicativeExpression)?;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	//multOps:
	//	"*" | "/";
	public MultOpsElements getMultOpsAccess() {
		return (pMultOps != null) ? pMultOps : (pMultOps = new MultOpsElements());
	}
	
	public ParserRule getMultOpsRule() {
		return getMultOpsAccess().getRule();
	}

	//unaryExpression:
	//	TermExpression | op=unaryOps expr=TermExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//unaryOps:
	//	"-" | "!";
	public UnaryOpsElements getUnaryOpsAccess() {
		return (pUnaryOps != null) ? pUnaryOps : (pUnaryOps = new UnaryOpsElements());
	}
	
	public ParserRule getUnaryOpsRule() {
		return getUnaryOpsAccess().getRule();
	}

	//Operator:
	//	op=OperatorName "(" sequence=ExpressionSequence ")";
	public OperatorElements getOperatorAccess() {
		return (pOperator != null) ? pOperator : (pOperator = new OperatorElements());
	}
	
	public ParserRule getOperatorRule() {
		return getOperatorAccess().getRule();
	}

	//TermExpression:
	//	TermLiteral | Operator;
	public TermExpressionElements getTermExpressionAccess() {
		return (pTermExpression != null) ? pTermExpression : (pTermExpression = new TermExpressionElements());
	}
	
	public ParserRule getTermExpressionRule() {
		return getTermExpressionAccess().getRule();
	}

	//TermLiteral:
	//	{VarRef} value=ID | {IntegerLiteral} value=INT | {BooleanLiteral} value=BOOLEAN | {StringLiteral} value=STRING |
	//	{DoubleLiteral} value=DOUBLE;
	public TermLiteralElements getTermLiteralAccess() {
		return (pTermLiteral != null) ? pTermLiteral : (pTermLiteral = new TermLiteralElements());
	}
	
	public ParserRule getTermLiteralRule() {
		return getTermLiteralAccess().getRule();
	}

	/////////////////////////////////////////////////////	
	//// pending validations, for Java editor callbacks	
	/////////////////////////////////////////////////////
	//// TODO create a validation rule that states attribute is only allowed for discrete nodes
	//// TODO subtype attribute only for discrete (chance or decision) node
	//// TODO state_values attribute only for nodes of type number or interval
	//// TODO state_values attribute must appear after subtype and states attributes
	//// TODO state_values if subtype number list length same as states list
	//// TODO state_values if subtype interval list length one greater than states list
	//// TODO potential graph children must be >0 if parents used
	//// TODO chance, decision, and utility nodes can only have chance and decision nodes as parents
	//// TODO discrete nodes can only have discrete nodes as parents
	//// TODO a node must not be referenced in a potential specification before it has been defined by a node, decision, utility, or function specification
	//// TODO mean value of normal distribution must be linear function of continuous graph parents, each term must be numeric constant, name of continuous parent, or constant followed by '*' followed by name of continuous parent
	//// TODO formal input name must refer to a node listed in the inputs attribute of the class with name
	//// TODO the node referred to by the actual input name must be defined somewhere in the class containing the class instance
	//OperatorName:
	//	"truncate" | "Normal" | "LogNormal" | "Beta" | "Gamma" | "Exponential" | "Weibull" | "Uniform" | "Triangular" | "PERT"
	//	| "Binomial" | "Poisson" | "NegativeBinomial" | "Geometric" | "Distribution" | "NoisyOR" | "min" | "max" | "log" |
	//	"log2" | "log10" | "exp" | "sin" | "cos" | "tan" | "sinh" | "cosh" | "tanh" | "sqrt" | "abs" | "floor" | "ceil" |
	//	"mod" | "if" | "and" | "or" | "not";
	public OperatorNameElements getOperatorNameAccess() {
		return (pOperatorName != null) ? pOperatorName : (pOperatorName = new OperatorNameElements());
	}
	
	public ParserRule getOperatorNameRule() {
		return getOperatorNameAccess().getRule();
	}
}
